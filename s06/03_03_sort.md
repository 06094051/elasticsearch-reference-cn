# 6.3.3 Sort

Sort 允许对特定的字段设置一种或多种排序条件。这些排序条件既可以正向排序，当然也都可以倒序排序。排序条件是针对每个字段的，而比较特殊的字段有，`_score`，这是用来告诉 elasticsearch 把结果根据相关度评分来进行排序，然后，`_doc`则是根据索引顺序来排序。

```bash
{
    "sort" : [
        { "post_date" : {"order" : "asc"}},
        "user",
        { "name" : "desc" },
        { "age" : "desc" },
        "_score"
    ],
    "query" : {
        "term" : { "user" : "kimchy" }
    }
}
```

> **Note**
> 
> `_doc` has no real use-case besides being the most efficient sort order. So if you don’t care about the order in which documents are returned, then you should sort by `_doc`. This especially helps when [scrolling](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-scroll.html).

## 顺序信息

顺序信息会作为查询结果的一部分被返回回来。 ~~这话好废。。。~~

## 排序方式

排序方式无非两种，递增和递减，这通过 `order` 参数来设置，该参数的可选项有：

* `asc` 递增

* `desc` 递减

当以相关度评分 `_score` 的值来排序时，`order` 默认是 `desc`，即递减的，而其他情况下默认是 `asc`，即递增的。
 
## 多值字段排序

即使某个字段存的是数组，或者其他形式的多个值，Elasticsearch 也支持用这类多值字段来进行排序。但是你需要指定怎么从多个值中挑选出一个代表性质的值来参与实际的排序操作，这就可以通过 `mode` 参数来设置，该参数的可选项有：

* `min` 以最小的那个值为准来进行排序操作

* `max` 以最大的那个值为准来进行排序操作

* `sum` 求和，并以算出的和为准。该选项仅适用于数值型的数组字段

* `avg` 求平均值，并以算出的平均值为准来进行排序操作。该选项仅适用于数值型的数组字段

* `median` 以所有值的 median 中间值为准来进行排序操作。该选项仅适用于数值型的数组字段

## Sort mode example usage

在本例中，假设每个文档中 price 价格字段都存储有多个值。然后下面这个示例代码意思就是，求出 price 价格的平均值，然后根据这个平均值，递增地进行排序

```bash
curl -XPOST 'localhost:9200/_search' -d '{
   "query" : {
    ...
   },
   "sort" : [
      {"price" : {"order" : "asc", "mode" : "avg"}}
   ]
}'
```

## Sorting within nested objects.

Elasticsearch also supports sorting by fields that are inside one or more nested objects. The sorting by nested field support has the following parameters on top of the already existing sort options:

* `nested_path` Defines on which nested object to sort. The actual sort field must be a direct field inside this nested object. When sorting by nested field, this field is mandatory.

* `nested_filter` A filter that the inner objects inside the nested path should match with in order for its field values to be taken into account by sorting. Common case is to repeat the query / filter inside the nested filter or query. By default no **`nested_filter`** is active.


## Nested sorting example

In the below example `offer` is a field of type `nested`. The `nested_path` needs to be specified; otherwise, elasticsearch doesn’t know on what nested level sort values need to be captured.

```bash
curl -XPOST 'localhost:9200/_search' -d '{
   "query" : {
    ...
   },
   "sort" : [
       {
          "offer.price" : {
             "mode" :  "avg",
             "order" : "asc",
             "nested_path" : "offer",
             "nested_filter" : {
                "term" : { "offer.color" : "blue" }
             }
          }
       }
    ]
}'
```

Nested sorting is also supported when sorting by scripts and sorting by geo distance.

## Missing Values

The `missing` parameter specifies how docs which are missing the field should be treated: The `missing` value can be set to `_last`, `_first`, or a custom value (that will be used for missing docs as the sort value). For example:

```bash
{
    "sort" : [
        { "price" : {"missing" : "_last"} },
    ],
    "query" : {
        "term" : { "user" : "kimchy" }
    }
}
```

> **Note**
> 
> If a nested inner object doesn’t match with the `nested_filter` then a missing value is used.

## Ignoring Unmapped Fields

By default, the search request will fail if there is no mapping associated with a field. The `unmapped_type` option allows to ignore fields that have no mapping and not sort by them. The value of this parameter is used to determine what sort values to emit. Here is an example of how it can be used:

```bash
{
    "sort" : [
        { "price" : {"unmapped_type" : "long"} },
    ],
    "query" : {
        "term" : { "user" : "kimchy" }
    }
}
```

If any of the indices that are queried doesn’t have a mapping for `price` then Elasticsearch will handle it as if there was a mapping of type `long`, with all documents in this index having no value for this field.

## Geo Distance Sorting

Allow to sort by `_geo_distance`. Here is an example:

```bash
{
    "sort" : [
        {
            "_geo_distance" : {
                "pin.location" : [-70, 40],
                "order" : "asc",
                "unit" : "km",
                "mode" : "min",
                "distance_type" : "sloppy_arc"
            }
        }
    ],
    "query" : {
        "term" : { "user" : "kimchy" }
    }
}
```

`distance_type` How to compute the distance. Can either be **`sloppy_arc`** (default), **`arc`** (slightly more precise but significantly slower) or **`plane`** (faster, but inaccurate on long distances and close to the poles).
Note: the geo distance sorting supports `sort_mode` options: `min`, `max` and `avg`.

The following formats are supported in providing the coordinates:

## Lat Lon as Properties

```bash
{
    "sort" : [
        {
            "_geo_distance" : {
                "pin.location" : {
                    "lat" : 40,
                    "lon" : -70
                },
                "order" : "asc",
                "unit" : "km"
            }
        }
    ],
    "query" : {
        "term" : { "user" : "kimchy" }
    }
}
```

## Lat Lon as String

Format in `lat`,`lon`.

```bash
{
    "sort" : [
        {
            "_geo_distance" : {
                "pin.location" : "40,-70",
                "order" : "asc",
                "unit" : "km"
            }
        }
    ],
    "query" : {
        "term" : { "user" : "kimchy" }
    }
}
```

## Geohash

```bash
{
    "sort" : [
        {
            "_geo_distance" : {
                "pin.location" : "drm3btev3e86",
                "order" : "asc",
                "unit" : "km"
            }
        }
    ],
    "query" : {
        "term" : { "user" : "kimchy" }
    }
}
```

## Lat Lon as Array

Format in [`lon`, `lat`], note, the order of lon/lat here in order to conform with [GeoJSON](http://geojson.org/).

```bash
{
    "sort" : [
        {
            "_geo_distance" : {
                "pin.location" : [-70, 40],
                "order" : "asc",
                "unit" : "km"
            }
        }
    ],
    "query" : {
        "term" : { "user" : "kimchy" }
    }
}
```

## Multiple reference points

Multiple geo points can be passed as an array containing any `geo_point` format, for example

```javascript
"pin.location" : [[-70, 40], [-71, 42]]
"pin.location" : [{"lat": 40, "lon": -70}, {"lat": 42, "lon": -71}]
```

and so forth.

The final distance for a document will then be `min`/`max`/`avg` (defined via `mode`) distance of all points contained in the document to all points given in the sort request.

## Script Based Sorting

Allow to sort based on custom scripts, here is an example:

```bash
{
    "query" : {
        ....
    },
    "sort" : {
        "_script" : {
            "type" : "number",
            "script" : {
                "inline": "doc['field_name'].value * factor",
                "params" : {
                    "factor" : 1.1
                }
            },
            "order" : "asc"
        }
    }
}
```

## Track Scores

When sorting on a field, scores are not computed. By setting `track_scores` to true, scores will still be computed and tracked.

```bash
{
    "track_scores": true,
    "sort" : [
        { "post_date" : {"order" : "desc"} },
        { "name" : "desc" },
        { "age" : "desc" }
    ],
    "query" : {
        "term" : { "user" : "kimchy" }
    }
}
```

## Memory Considerations

When sorting, the relevant sorted field values are loaded into memory. This means that per shard, there should be enough memory to contain them. For string based types, the field sorted on should not be analyzed / tokenized. For numeric types, if possible, it is recommended to explicitly set the type to narrower types (like `short`, `integer` and `float`).

***


Allows to add one or more sort on specific fields. Each sort can be reversed as well. The sort is defined on a per field level, with special field name for `_score` to sort by score, and `_doc` to sort by index order.

```bash
{
    "sort" : [
        { "post_date" : {"order" : "asc"}},
        "user",
        { "name" : "desc" },
        { "age" : "desc" },
        "_score"
    ],
    "query" : {
        "term" : { "user" : "kimchy" }
    }
}
```

> **Note**
> 
> `_doc` has no real use-case besides being the most efficient sort order. So if you don’t care about the order in which documents are returned, then you should sort by `_doc`. This especially helps when [scrolling](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-scroll.html).

## Sort Values

The sort values for each document returned are also returned as part of the response.

## Sort Order

The `order` option can have the following values:

* `asc` Sort in ascending order

* `desc` Sort in descending order

The order defaults to `desc` when sorting on the `_score`, and defaults to `asc` when sorting on anything else.

## Sort mode option

Elasticsearch supports sorting by array or multi-valued fields. The `mode` option controls what array value is picked for sorting the document it belongs to. The `mode` option can have the following values:

* `min` Pick the lowest value.

* `max` Pick the highest value.

* `sum` Use the sum of all values as sort value. Only applicable for number based array fields.

* `avg` Use the average of all values as sort value. Only applicable for number based array fields.

* `median` Use the median of all values as sort value. Only applicable for number based array fields.

## Sort mode example usage

In the example below the field price has multiple prices per document. In this case the result hits will be sort by price ascending based on the average price per document.

```bash
curl -XPOST 'localhost:9200/_search' -d '{
   "query" : {
    ...
   },
   "sort" : [
      {"price" : {"order" : "asc", "mode" : "avg"}}
   ]
}'
```

## Sorting within nested objects.

Elasticsearch also supports sorting by fields that are inside one or more nested objects. The sorting by nested field support has the following parameters on top of the already existing sort options:

* `nested_path` Defines on which nested object to sort. The actual sort field must be a direct field inside this nested object. When sorting by nested field, this field is mandatory.

* `nested_filter` A filter that the inner objects inside the nested path should match with in order for its field values to be taken into account by sorting. Common case is to repeat the query / filter inside the nested filter or query. By default no **`nested_filter`** is active.


## Nested sorting example

In the below example `offer` is a field of type `nested`. The `nested_path` needs to be specified; otherwise, elasticsearch doesn’t know on what nested level sort values need to be captured.

```bash
curl -XPOST 'localhost:9200/_search' -d '{
   "query" : {
    ...
   },
   "sort" : [
       {
          "offer.price" : {
             "mode" :  "avg",
             "order" : "asc",
             "nested_path" : "offer",
             "nested_filter" : {
                "term" : { "offer.color" : "blue" }
             }
          }
       }
    ]
}'
```

Nested sorting is also supported when sorting by scripts and sorting by geo distance.

## Missing Values

The `missing` parameter specifies how docs which are missing the field should be treated: The `missing` value can be set to `_last`, `_first`, or a custom value (that will be used for missing docs as the sort value). For example:

```bash
{
    "sort" : [
        { "price" : {"missing" : "_last"} },
    ],
    "query" : {
        "term" : { "user" : "kimchy" }
    }
}
```

> **Note**
> 
> If a nested inner object doesn’t match with the `nested_filter` then a missing value is used.

## Ignoring Unmapped Fields

By default, the search request will fail if there is no mapping associated with a field. The `unmapped_type` option allows to ignore fields that have no mapping and not sort by them. The value of this parameter is used to determine what sort values to emit. Here is an example of how it can be used:

```bash
{
    "sort" : [
        { "price" : {"unmapped_type" : "long"} },
    ],
    "query" : {
        "term" : { "user" : "kimchy" }
    }
}
```

If any of the indices that are queried doesn’t have a mapping for `price` then Elasticsearch will handle it as if there was a mapping of type `long`, with all documents in this index having no value for this field.

## Geo Distance Sorting

Allow to sort by `_geo_distance`. Here is an example:

```bash
{
    "sort" : [
        {
            "_geo_distance" : {
                "pin.location" : [-70, 40],
                "order" : "asc",
                "unit" : "km",
                "mode" : "min",
                "distance_type" : "sloppy_arc"
            }
        }
    ],
    "query" : {
        "term" : { "user" : "kimchy" }
    }
}
```

`distance_type` How to compute the distance. Can either be **`sloppy_arc`** (default), **`arc`** (slightly more precise but significantly slower) or **`plane`** (faster, but inaccurate on long distances and close to the poles).
Note: the geo distance sorting supports `sort_mode` options: `min`, `max` and `avg`.

The following formats are supported in providing the coordinates:

## Lat Lon as Properties

```bash
{
    "sort" : [
        {
            "_geo_distance" : {
                "pin.location" : {
                    "lat" : 40,
                    "lon" : -70
                },
                "order" : "asc",
                "unit" : "km"
            }
        }
    ],
    "query" : {
        "term" : { "user" : "kimchy" }
    }
}
```

## Lat Lon as String

Format in `lat`,`lon`.

```bash
{
    "sort" : [
        {
            "_geo_distance" : {
                "pin.location" : "40,-70",
                "order" : "asc",
                "unit" : "km"
            }
        }
    ],
    "query" : {
        "term" : { "user" : "kimchy" }
    }
}
```

## Geohash

```bash
{
    "sort" : [
        {
            "_geo_distance" : {
                "pin.location" : "drm3btev3e86",
                "order" : "asc",
                "unit" : "km"
            }
        }
    ],
    "query" : {
        "term" : { "user" : "kimchy" }
    }
}
```

## Lat Lon as Array

Format in [`lon`, `lat`], note, the order of lon/lat here in order to conform with [GeoJSON](http://geojson.org/).

```bash
{
    "sort" : [
        {
            "_geo_distance" : {
                "pin.location" : [-70, 40],
                "order" : "asc",
                "unit" : "km"
            }
        }
    ],
    "query" : {
        "term" : { "user" : "kimchy" }
    }
}
```

## Multiple reference points

Multiple geo points can be passed as an array containing any `geo_point` format, for example

```javascript
"pin.location" : [[-70, 40], [-71, 42]]
"pin.location" : [{"lat": 40, "lon": -70}, {"lat": 42, "lon": -71}]
```

and so forth.

The final distance for a document will then be `min`/`max`/`avg` (defined via `mode`) distance of all points contained in the document to all points given in the sort request.

## Script Based Sorting

Allow to sort based on custom scripts, here is an example:

```bash
{
    "query" : {
        ....
    },
    "sort" : {
        "_script" : {
            "type" : "number",
            "script" : {
                "inline": "doc['field_name'].value * factor",
                "params" : {
                    "factor" : 1.1
                }
            },
            "order" : "asc"
        }
    }
}
```

## Track Scores

When sorting on a field, scores are not computed. By setting `track_scores` to true, scores will still be computed and tracked.

```bash
{
    "track_scores": true,
    "sort" : [
        { "post_date" : {"order" : "desc"} },
        { "name" : "desc" },
        { "age" : "desc" }
    ],
    "query" : {
        "term" : { "user" : "kimchy" }
    }
}
```

## Memory Considerations

When sorting, the relevant sorted field values are loaded into memory. This means that per shard, there should be enough memory to contain them. For string based types, the field sorted on should not be analyzed / tokenized. For numeric types, if possible, it is recommended to explicitly set the type to narrower types (like `short`, `integer` and `float`).